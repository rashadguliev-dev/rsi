// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© LuxAlgo
// Modified for Multi-Timeframe RSI/EMA Crossover Signals with Economic Viability Filter
// Optimized by "Jules" (AI Quant)

//@version=5
indicator("MTF Ultimate RSI with Economic Viability [Jules]", "MTF Ultimate RSI + EV", overlay=true, max_labels_count=500)

//------------------------------------------------------------------------------
//Multi-Timeframe Settings
//-----------------------------------------------------------------------------{
htf = input.timeframe("5", "Higher Timeframe", tooltip="Timeframe for RSI and EMA calculations", group="Multi-Timeframe")

//------------------------------------------------------------------------------
//Original Ultimate RSI Settings
//-----------------------------------------------------------------------------{
length = input.int(14, minval = 2, group="Ultimate RSI")
smoType1 = input.string('RMA', 'RSI Method', options = ['EMA', 'SMA', 'RMA', 'TMA'], group="Ultimate RSI")
src = input(close, 'Source', group="Ultimate RSI")

//Signal Line (EMA)
smooth = input.int(14, minval = 1, group = 'Signal Line (EMA)')
smoType2 = input.string('EMA', 'EMA Method', options = ['EMA', 'SMA', 'RMA', 'TMA'], group = 'Signal Line (EMA)')

//------------------------------------------------------------------------------
//Economic Viability Filter Settings (New)
//-----------------------------------------------------------------------------{
atr_threshold_pct = input.float(0.3, "Min ATR (%)", minval=0.0, step=0.05, group="Economic Viability Filter", tooltip="Minimum ATR(14) as % of price required to take a trade. \nDerived from statistical analysis: < 0.3% implies negative expectancy.")
vol_threshold_rel = input.float(1.0, "Min Relative Volume", minval=0.0, step=0.1, group="Economic Viability Filter", tooltip="Minimum Volume relative to SMA(20) required. \nEnsures market participation.")
show_filtered = input.bool(true, "Show Filtered Signals (Gray)", group="Economic Viability Filter")

//Crossover Signals Settings
show_long_signals = input.bool(true, "Show Long Signals", group="Crossover Signals")
show_short_signals = input.bool(true, "Show Short Signals", group="Crossover Signals")
long_color = input.color(color.green, "Long Signal Color", group="Crossover Signals")
short_color = input.color(color.red, "Short Signal Color", group="Crossover Signals")
filtered_color = input.color(color.gray, "Filtered Signal Color", group="Crossover Signals")
signal_size = input.string("small", "Signal Size", options=["tiny", "small", "normal", "large", "huge"], group="Crossover Signals")

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
ma(x, len, maType) =>
    switch maType
        'EMA' => ta.ema(x, len)
        'SMA' => ta.sma(x, len)
        'RMA' => ta.rma(x, len)
        'TMA' => ta.sma(ta.sma(x, len), len)

//-----------------------------------------------------------------------------}
//Multi-Timeframe Calculation
//-----------------------------------------------------------------------------{
// Combined function to get all HTF data in one call
calc_all(source, rsi_length, rsi_method, ema_length, ema_method, atr_len, vol_len) =>
    // RSI Calc
    upper = ta.highest(source, rsi_length)
    lower = ta.lowest(source, rsi_length)
    r = upper - lower
    d = source - source[1]
    diff = upper > upper[1] ? r : lower < lower[1] ? -r : d
    num = ma(diff, rsi_length, rsi_method)
    den = ma(math.abs(diff), rsi_length, rsi_method)
    ultimate_rsi = num / den * 50 + 50
    signal_line = ma(ultimate_rsi, ema_length, ema_method)

    // ATR Calc
    atr_val = ta.atr(atr_len)
    atr_p = (atr_val / source) * 100

    // Volume Calc (handle if volume is na, e.g. some index feeds)
    vol_val = nz(volume)
    vol_ma = ma(vol_val, vol_len, 'SMA')
    vol_rel = vol_ma != 0 ? vol_val / vol_ma : 0

    [ultimate_rsi, signal_line, atr_p, vol_rel]

// Request Security
[htf_arsi, htf_signal, htf_atr_pct, htf_vol_rel] = request.security(syminfo.tickerid, htf, calc_all(src, length, smoType1, smooth, smoType2, 14, 20), lookahead=barmerge.lookahead_off)

//-----------------------------------------------------------------------------}
//Crossover Signal Detection & Filtering
//-----------------------------------------------------------------------------{
// 1. Raw Signals
raw_long = ta.crossover(htf_arsi, htf_signal)
raw_short = ta.crossunder(htf_arsi, htf_signal)

// 2. Economic Viability Condition
is_viable = (htf_atr_pct >= atr_threshold_pct) and (htf_vol_rel >= vol_threshold_rel)

// 3. Final Signals (Confirmed bar)
long_signal = show_long_signals and barstate.isconfirmed and raw_long and is_viable
short_signal = show_short_signals and barstate.isconfirmed and raw_short and is_viable

// 4. Filtered Signals (for display)
filtered_long = show_long_signals and barstate.isconfirmed and raw_long and not is_viable
filtered_short = show_short_signals and barstate.isconfirmed and raw_short and not is_viable

//-----------------------------------------------------------------------------}
//Visuals
//-----------------------------------------------------------------------------{
// Valid Signals
if long_signal
    label.new(bar_index, low * 0.999, "LONG\n" + htf, color=long_color, style=label.style_label_up, textcolor=color.white, size=signal_size == "tiny" ? size.tiny : signal_size == "small" ? size.small : signal_size == "normal" ? size.normal : signal_size == "large" ? size.large : size.huge, tooltip="HTF Ultimate RSI crossed above EMA\nATR%: " + str.tostring(htf_atr_pct, "#.##") + "%\nVol Rel: " + str.tostring(htf_vol_rel, "#.##"))

if short_signal
    label.new(bar_index, high * 1.001, "SHORT\n" + htf, color=short_color, style=label.style_label_down, textcolor=color.white, size=signal_size == "tiny" ? size.tiny : signal_size == "small" ? size.small : signal_size == "normal" ? size.normal : signal_size == "large" ? size.large : size.huge, tooltip="HTF Ultimate RSI crossed below EMA\nATR%: " + str.tostring(htf_atr_pct, "#.##") + "%\nVol Rel: " + str.tostring(htf_vol_rel, "#.##"))

// Filtered Signals
if show_filtered
    if filtered_long
        label.new(bar_index, low * 0.999, "X", color=filtered_color, style=label.style_label_up, textcolor=color.white, size=size.tiny, tooltip="FILTERED LONG\nATR%: " + str.tostring(htf_atr_pct, "#.##") + "% < " + str.tostring(atr_threshold_pct, "#.##") + "%\nOR Vol: " + str.tostring(htf_vol_rel, "#.##") + " < " + str.tostring(vol_threshold_rel, "#.##"))
    if filtered_short
        label.new(bar_index, high * 1.001, "X", color=filtered_color, style=label.style_label_down, textcolor=color.white, size=size.tiny, tooltip="FILTERED SHORT\nATR%: " + str.tostring(htf_atr_pct, "#.##") + "% < " + str.tostring(atr_threshold_pct, "#.##") + "%\nOR Vol: " + str.tostring(htf_vol_rel, "#.##") + " < " + str.tostring(vol_threshold_rel, "#.##"))

//-----------------------------------------------------------------------------}
//Table
//-----------------------------------------------------------------------------{
show_table = input.bool(true, "Show HTF Info Table", group="Display")
table_position = input.string("top_right", "Table Position", options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group="Display")

if show_table and barstate.islast
    table_pos = table_position == "top_left" ? position.top_left : table_position == "top_center" ? position.top_center : table_position == "top_right" ? position.top_right : table_position == "middle_left" ? position.middle_left : table_position == "middle_center" ? position.middle_center : table_position == "middle_right" ? position.middle_right : table_position == "bottom_left" ? position.bottom_left : table_position == "bottom_center" ? position.bottom_center : position.bottom_right

    var table info_table = table.new(table_pos, 2, 6, bgcolor=color.new(color.white, 80), border_width=1)

    table.cell(info_table, 0, 0, "HTF:", text_color=color.black, text_size=size.small)
    table.cell(info_table, 1, 0, htf, text_color=color.blue, text_size=size.small)

    table.cell(info_table, 0, 1, "RSI:", text_color=color.black, text_size=size.small)
    table.cell(info_table, 1, 1, str.tostring(htf_arsi, "#.##"), text_color=htf_arsi > htf_signal ? color.green : color.red, text_size=size.small)

    table.cell(info_table, 0, 2, "Trend:", text_color=color.black, text_size=size.small)
    table.cell(info_table, 1, 2, htf_arsi > htf_signal ? "BULL" : "BEAR", text_color=htf_arsi > htf_signal ? color.green : color.red, text_size=size.small)

    table.cell(info_table, 0, 3, "ATR %:", text_color=color.black, text_size=size.small)
    table.cell(info_table, 1, 3, str.tostring(htf_atr_pct, "#.##") + "%", text_color=htf_atr_pct >= atr_threshold_pct ? color.green : color.red, text_size=size.small)

    table.cell(info_table, 0, 4, "Vol Rel:", text_color=color.black, text_size=size.small)
    table.cell(info_table, 1, 4, str.tostring(htf_vol_rel, "#.##"), text_color=htf_vol_rel >= vol_threshold_rel ? color.green : color.red, text_size=size.small)

    table.cell(info_table, 0, 5, "Market:", text_color=color.black, text_size=size.small)
    table.cell(info_table, 1, 5, is_viable ? "VIABLE" : "NO PAY", text_color=is_viable ? color.green : color.red, text_size=size.small, tooltip="Can Market pay > 0.2%?")
